#include "CandleCloseEventObserver.h"
#include <QtGlobal>
#include <QDateTime>
#include <QTimeZone>

// We need to include all of the autogenerated CandleCloseEvent subclasses:
#include "trading/event/type/CandleCloseEvents.h"

CandleCloseEventObserver::CandleCloseEventObserver(EventHandler* handler, QObject* parent)
    : QObject(parent), eventHandler(handler)
{
    // Get “now” in UTC once, so that all initial lastDispatched values line up to the same moment.
    const QDateTime nowUtc = QDateTime::currentDateTimeUtc();

    //
    // Register every interval we care about. Each call to registerCandleEvent()
    // will store the factory and initialize lastDispatched[interval] so that we
    // do NOT fire any past‐history events. Only future closes (i.e. “new” closes)
    // will ever get dispatched from poll().
    //

    // 1-minute
    registerCandleEvent(1, [](){ return new m1CandleCloseEvent(); });
    // 5-minute
    registerCandleEvent(5, [](){ return new m5CandleCloseEvent(); });
    // 15-minute
    registerCandleEvent(15, [](){ return new m15CandleCloseEvent(); });
    // 30-minute
    registerCandleEvent(30, [](){ return new m30CandleCloseEvent(); });
    // 1-hour = 60 min
    registerCandleEvent(60, [](){ return new H1CandleCloseEvent(); });
    // 2-hour = 120 min
    registerCandleEvent(120, [](){ return new H2CandleCloseEvent(); });
    // 4-hour = 240 min
    registerCandleEvent(240, [](){ return new H4CandleCloseEvent(); });
    // 8-hour = 480 min
    registerCandleEvent(480, [](){ return new H8CandleCloseEvent(); });
    // 12-hour = 720 min
    registerCandleEvent(720, [](){ return new H12CandleCloseEvent(); });
    // 1-day = 1440 min
    registerCandleEvent(1440, [](){ return new D1CandleCloseEvent(); });
    // 1-week = 10080 min (7 days × 24 h × 60 min)
    registerCandleEvent(10080, [](){ return new W1CandleCloseEvent(); });
    // 1-month (special): we use 43200 as a “marker” for monthly
    registerCandleEvent(43200, [](){ return new M1CandleCloseEvent(); });
    // 4-month
    registerCandleEvent(4 * 43200, [](){ return new M4CandleCloseEvent(); });
    // 6-month
    registerCandleEvent(6 * 43200, [](){ return new M6CandleCloseEvent(); });
    // 1-year (special): we use 525600 as a “marker” for yearly
    registerCandleEvent(525600, [](){ return new Y1CandleCloseEvent(); });

    //
    // Additional “month”“year”‐aligned intervals may be registered the same way:
    // e.g. if someone wanted a 2-month candle, they could register 2*43200 here, etc.
    //
}

void CandleCloseEventObserver::registerCandleEvent(int intervalMinutes, std::function<CandleClose*()> factory)
{
    // Store the factory
    candleFactories.insert(intervalMinutes, factory);

    // Compute and store the “last discharged” close‐time so that we do not fire historical events.
    const QDateTime nowUtc = QDateTime::currentDateTimeUtc();
    QDateTime lastClose;

    if (intervalMinutes == 43200) {
        // “monthly” boundary
        lastClose = calculateLastMonthlyClose(nowUtc);
    }
    else if (intervalMinutes == 525600) {
        // “yearly” boundary
        lastClose = calculateLastYearlyClose(nowUtc);
    }
    else {
        // fixed‐minute interval
        lastClose = calculateLastFixedCandleClose(nowUtc, intervalMinutes);
    }

    lastDispatched.insert(intervalMinutes, lastClose);
}

void CandleCloseEventObserver::poll()
{
    const QDateTime nowUtc = QDateTime::currentDateTimeUtc();

    // For every registered interval, check whether “now” has crossed a new close boundary.
    for (auto it = candleFactories.constBegin(); it != candleFactories.constEnd(); ++it) {
        int interval = it.key();
        const auto& factory = it.value();

        // Determine what the “latest close” would be, as of now.
        QDateTime latestClose;
        if (interval == 43200) {
            latestClose = calculateLastMonthlyClose(nowUtc);
        }
        else if (interval == 525600) {
            latestClose = calculateLastYearlyClose(nowUtc);
        }
        else {
            latestClose = calculateLastFixedCandleClose(nowUtc, interval);
        }

        // Check if we have already dispatched that timestamp. If not, fire exactly one event.
        const QDateTime& lastSent = lastDispatched.value(interval);
        if (latestClose > lastSent) {
            // Create the event, set its close‐time, and hand it off to EventHandler.
            CandleClose* evt = factory();
            evt->setCloseTime(latestClose);

            // If you have a way to fill in actual Candle data (OHLC), you can do so here:
            //    Candle c = fetchCandleData(interval, latestClose);
            //    evt->setCandle(c);
            //
            // For now, we simply dispatch the close time and leave the Candle object empty.

            eventHandler->dispatch(*evt);
            delete evt;

            // Update “lastDispatched” so we don’t fire again for the same timestamp.
            lastDispatched[interval] = latestClose;
        }
    }
}

QDateTime CandleCloseEventObserver::calculateLastFixedCandleClose(const QDateTime& nowUtc, int intervalMinutes) const
{
    // Convert nowUtc to epoch‐seconds (UTC)
    qint64 secsSinceEpoch = nowUtc.toSecsSinceEpoch();

    // Number of seconds per candle
    qint64 intervalSecs = static_cast<qint64>(intervalMinutes) * 60;

    // How many complete intervals have passed since epoch?
    qint64 bucketCount = secsSinceEpoch / intervalSecs;

    // The last close time is bucketCount * intervalSecs
    qint64 lastCloseSecs = bucketCount * intervalSecs;

    return QDateTime::fromSecsSinceEpoch(lastCloseSecs, QTimeZone::UTC);
}

QDateTime CandleCloseEventObserver::calculateLastMonthlyClose(const QDateTime& nowUtc) const
{
    // Extract date (UTC) from QDateTime
    QDate d = nowUtc.date();

    // Build a QDateTime for the first of THIS month at 00:00 UTC
    QDate firstOfThisMonth(d.year(), d.month(), 1);
    QDateTime dtFirstOfThisMonth(firstOfThisMonth, QTime(0,0,0), QTimeZone::UTC);

    if (nowUtc >= dtFirstOfThisMonth) {
        // That instant is precisely the close of last month
        return dtFirstOfThisMonth;
    }
    else {
        // We are still in the first instant of the month—so we must go back to previous month
        int year = d.year();
        int month = d.month() - 1;
        if (month < 1) {
            month = 12;
            year -= 1;
        }
        QDate previousMonthFirst(year, month, 1);
        return QDateTime(previousMonthFirst, QTime(0,0,0), QTimeZone::UTC);
    }
}

QDateTime CandleCloseEventObserver::calculateLastYearlyClose(const QDateTime& nowUtc) const
{
    // Extract date (UTC) from QDateTime
    QDate d = nowUtc.date();

    // Build a QDateTime for Jan 1 of THIS year at 00:00 UTC
    QDate firstOfThisYear(d.year(), 1, 1);
    QDateTime dtFirstOfThisYear(firstOfThisYear, QTime(0,0,0), QTimeZone::UTC);

    if (nowUtc >= dtFirstOfThisYear) {
        // That instant is precisely the close of last year
        return dtFirstOfThisYear;
    }
    else {
        // We are still in the first instant of the year—so we must go back to previous year
        int year = d.year() - 1;
        QDate firstOfPrevYear(year, 1, 1);
        return QDateTime(firstOfPrevYear, QTime(0,0,0), QTimeZone::UTC);
    }
}
